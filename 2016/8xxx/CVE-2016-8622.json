{
    "data_type": "CVE",
    "data_format": "MITRE",
    "data_version": "4.0",
    "CVE_data_meta": {
        "ID": "CVE-2016-8622",
        "ASSIGNER": "psampaio@redhat.com"
    },
    "affects": {
        "vendor": {
            "vendor_data": [
                {
                    "vendor_name": "The Curl Project",
                    "product": {
                        "product_data": [
                            {
                                "product_name": "curl",
                                "version": {
                                    "version_data": [
                                        {
                                            "version_value": "7.51.0"
                                        }
                                    ]
                                }
                            }
                        ]
                    }
                }
            ]
        }
    },
    "problemtype": {
        "problemtype_data": [
            {
                "description": [
                    {
                        "lang": "eng",
                        "value": "CWE-190"
                    }
                ]
            },
            {
                "description": [
                    {
                        "lang": "eng",
                        "value": "CWE-122"
                    }
                ]
            }
        ]
    },
    "references": {
        "reference_data": [
            {
                "url": "https://curl.haxx.se/docs/adv_20161102H.html"
            },
            {
                "url": "https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2016-8622",
                "name": "https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2016-8622",
                "refsource": "CONFIRM"
            }
        ]
    },
    "description": {
        "description_data": [
            {
                "lang": "eng",
                "value": "The URL percent-encoding decode function in libcurl befor 7.51.0 is called
`curl_easy_unescape`. Internally, even if this function would be made to
allocate a unscape destination buffer larger than 2GB, it would return that
new length in a signed 32 bit integer variable, thus the length would get
either just truncated or both truncated and turned negative. That could then
lead to libcurl writing outside of its heap based buffer."
            }
        ]
    },
    "impact": {
        "cvss": [
            [
                {
                    "vectorString": "3.7/CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:L/A:N",
                    "version": "3.0"
                }
            ],
            [
                {
                    "vectorString": "2.6/AV:N/AC:H/Au:N/C:N/I:P/A:N",
                    "version": "2.0"
                }
            ]
        ]
    }
}
